package com.code.datastructures.sort

import kotlin.system.measureTimeMillis

fun main(args: Array<String>) {
	
	// 测试一下快排的速度O(n^2), 给80000个数据，测试
	// 创建要给80000个的随机的数组
	var arr = IntArray(80000)
	for (i in 0 until 80000){
		arr[i] = (0..800000).random()
	}
	val elapsedTime = measureTimeMillis {
		quickSort(arr,0,arr.size-1)
	}
	
	println("total time :$elapsedTime")
}

/**
快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
	(1) 首先设定一个分界值，通过该分界值将数组分成左右两部分。
	(2) 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。
		此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 [2]
	(3) 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，
		同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2]
	(4) 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，
		再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了
 * */

fun quickSort(arr: IntArray, left: Int, right: Int){
	// 左下标
	var l = left
	// 右下标
	var r  =right
	// pivot 中轴值
	var pivot = arr[(left + right) / 2]
	// 临时变量，作为交换时使用
	var tmp = 0
	
	// while循环的目的将
	// 比pivot值晓得放到左边
	// 比pivot值大的放到右边
	while (l < r){
		//在pivot的左边一直找,找到大于等于pivot值,才退出
		while (arr[l] < pivot) {
			l += 1
		}
		//在pivot的右边一直找,找到小于等于pivot值,才退出
		while (arr[r] > pivot) {
			r -= 1
		}
		
		//如果l >= r说明pivot 的左右两的值，已经按照左边全部是
		//小于等于pivot值，右边全部是大于等于pivot值
		if (l >= r) {
			break
		}
		//交换
		tmp = arr[l]
		arr[l] = arr[r]
		arr[r] = tmp
		
		//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移
		if (arr[l] == pivot) {
			r -= 1
		}
		
		//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移
		if (arr[r] == pivot) {
			l += 1
		}
	}
	
	// 如果 l == r, 必须l++, r--, 否则为出现栈溢出
	if (l == r) {
		l += 1
		r -= 1
	}
	
	//向左递归
	if (left < r) {
		quickSort(arr, left, r)
	}
	//向右递归
	if (right > l) {
		quickSort(arr, l, right)
	}
	
}

/**
 * 原理
设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，
然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。
值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。

一趟快速排序的算法是：
	1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； [1]
	2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； [1]
	3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换； [1]
	4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换； [1]
	5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，
       直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 [1]
排序演示
	假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。
	此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。
	此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。
	此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。
	此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。
	此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。
	此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序
 * */